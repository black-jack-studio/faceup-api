Diagnose and fix PATCH /api/user/profile returning 500 (“Failed to sync user updates”).

Goal:
- Make PATCH /api/user/profile succeed (200) when updating the current user's profile (coins/gems/tickets/username/avatar etc.), or return a structured 4xx/5xx with full Supabase error details. No more silent “Error {}”.
- Use Supabase (not Neon/Replit DB) and RLS (authenticated user can update only their own row).

Tasks:

1) Add a small “safe()” helper and instrument the route to always log structured errors:
   const safe = (e: any) => ({
     message: e?.message || 'unknown',
     details: e?.details || e?.hint || null,
     code: e?.code || null,
     stack: process.env.NODE_ENV !== 'production' ? e?.stack : undefined,
   });

2) In PATCH /api/user/profile:
   - Derive userId from Supabase auth (cookie/JWT). Log it: console.log('[API] PATCH /api/user/profile uid=', userId, 'body keys=', Object.keys(req.body||{})).
   - Whitelist only allowed fields from req.body: { username, avatar, coins, gems, tickets, card_back } and drop undefined.
     Also coerce numerics: coins/gems/tickets must be integers if provided (parseInt). Do NOT send undefined to Supabase.
   - Call Supabase (the same supabase client used for auth, not a Neon pool):
     const { data, error } = await supabase
       .from('profiles')
       .update(allowedPayload)
       .eq('user_id', userId)
       .select('user_id, username, coins, gems, tickets, avatar, card_back')
       .single();
     if (error) throw error;
     if (!data) throw new Error('Update returned 0 rows');

   - On success: return res.status(200).json({ ok:true, profile:data }).
   - On error: console.error('[API ERROR] PATCH /api/user/profile', safe(err)); return res.status(400).json({ error: safe(err) });

3) Add a quick diagnostic endpoint (temporary):
   GET /api/debug/profiles-row
   - Reads current userId from Supabase auth.
   - SELECT * FROM public.profiles WHERE user_id = userId LIMIT 1
   - Return { exists: !!row, rowColumns: Object.keys(row||{}) }
   This tells us if the row exists and which columns the server sees.

4) Verify we are NOT using any Neon/Replit DB connection in this route. Use the Supabase client only.
   Remove/ignore any import of a Pool or PG* env in this handler.

5) Frontend:
   - Ensure all places that mutate profile (avatar, coins update, betting, shop) call PATCH /api/user/profile with only whitelisted fields.
   - For each failed response (!response.ok), log: console.error('profile PATCH failed', res.status, await res.text()) so we can see the JSON error from step #2.

6) Test plan (keep logs/screenshots in task):
   - Load home → open DevTools Network.
   - Trigger a simple update (change avatar or call coins +100 test).
   - If it fails: Network → click the failing PATCH → copy Response body. We expect a JSON with { error: {message, code, details, stack?} }.
   - Fix accordingly if the error says “RLS”, “column does not exist”, or “update 0 rows”.

Acceptance:
- PATCH /api/user/profile works and returns 200 with the updated row, or returns a structured JSON error (no “Error {}”).
- /api/debug/profiles-row returns exists:true for the logged-in user and shows expected columns.
- Betting / shop / avatar update no longer show “Failed to sync user updates”.

Do not refactor unrelated code. Keep changes minimal and focused on this route and logging.