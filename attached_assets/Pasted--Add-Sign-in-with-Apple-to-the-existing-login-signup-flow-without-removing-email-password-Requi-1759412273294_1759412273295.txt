

Add “Sign in with Apple” to the existing login/signup flow without removing email/password.

Requirements
	1.	Create a reusable component AppleLoginButton.tsx that calls:

await supabase.auth.signInWithOAuth({
  provider: 'apple',
  options: {
    redirectTo: `${window.location.origin}/auth/callback`
  }
})

The button must look like a native Apple sign-in (black background, Apple logo, accessible, clickable div or button).
	2.	On the signin/register page, import and render <AppleLoginButton /> below the existing form, with a small “— or —” separator. Do not touch existing email/password fields.
	3.	Add a minimal route/handler for the OAuth return:

	•	Frontend route: /auth/callback
	•	On mount, call supabase.auth.getSession() and supabase.auth.getUser().
If a session exists, call GET /api/user/profile. If 200, redirect to / (home).
If no session or error, redirect to /signin with a toast “Sign-in failed”.

	4.	Make sure our Supabase client uses env vars already present:

	•	VITE_SUPABASE_URL
	•	VITE_SUPABASE_ANON_KEY
(Do not hardcode anything)

	5.	Do not write to DB manually on OAuth success. We rely on our existing trigger to create/update public.profiles. The API GET /api/user/profile must be the single source of truth (username, coins, gems, tickets).
	6.	Add console diagnostics (only in dev):

	•	Before redirect: log “Starting Apple OAuth…”
	•	In /auth/callback: log session result and user id/email (no secrets)
	•	If GET /api/user/profile fails, log status and body.

	7.	Ensure the login page still works with email/password exactly as before. Do not remove or rename existing components/exports.

Acceptance
	•	Clicking “Sign in with Apple” opens the Apple sheet, then returns to /auth/callback, then lands on / with a populated profile (username/coins visible).
	•	If Apple denies or user cancels, we end at /signin with a toast error.
	•	No direct INSERT/UPDATE from client code into profiles—only GET /api/user/profile after auth.

Do not change any other flows. Keep changes minimal and additive.
